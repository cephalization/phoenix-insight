# Project Learnings Log

This file is appended by each agent after completing a task.
Key insights, gotchas, and patterns discovered during implementation.

Use this knowledge to avoid repeating mistakes and build on what works.

---

<!-- Agents: Append your learnings below this line -->
<!-- Format:
## <task-id>

- Key insight or decision made
- Gotcha or pitfall discovered
- Pattern that worked well
- Anything the next agent should know
-->

## monorepo-init

- Converted the existing single-package root package.json into a workspace root by making it `private: true` and moving shared devDependencies
- The workspace scripts use `pnpm -r run <script>` to run scripts across all packages
- The pnpm-workspace.yaml file uses `packages/*` glob to match all packages in the packages directory
- The next task (move-cli-package) needs to recreate package.json inside packages/cli/ with all the CLI-specific dependencies that were removed from root (like @ai-sdk/anthropic, commander, etc.)
- Updated .gitignore to use `packages/*/dist/` pattern for ignoring build outputs in all packages
- The root package name changed to `phoenix-insight-monorepo` (private) - the CLI package should retain the original name `@cephalization/phoenix-insight`

## move-cli-package

- Used `git mv` to move `src/`, `test/`, `tsconfig.json`, `tsconfig.esm.json`, `README.md`, `.changeset/`, and `vitest.config.ts` to `packages/cli/`
- Also moved `CHANGELOG.md` (generated by changesets) to `packages/cli/`
- Removed the old `dist/` directory at root level (leftover from before monorepo structure)
- Created a new `packages/cli/package.json` by restoring the CLI-specific dependencies from git history (`git show f75f13f^:package.json`)
- The CLI package.json excludes shared devDependencies (rimraf, typescript, vitest, tsx, @types/node) that are now at root level
- No import paths needed to be changed because all internal imports use relative paths
- All 384 tests pass, build succeeds - the move was transparent to the codebase
- Next tasks will need to create `packages/ui/` for the UI package

## scaffold-ui-package

- Used `pnpm create vite packages/ui --template react-ts` to scaffold the base Vite React TypeScript app
- Updated package.json with name `@cephalization/phoenix-insight-ui`, added `"private": true`, and scripts for `clean`, `test`, `typecheck`
- Added `--passWithNoTests` to the test script since the scaffolded project has no test files initially - prevents CI failures
- Tailwind v4 uses the new `@tailwindcss/vite` plugin and `@import "tailwindcss"` in CSS instead of the old `@tailwind` directives
- Configured path alias `@/*` pointing to `./src/*` in both `tsconfig.app.json` (TypeScript) and `vite.config.ts` (Vite bundler) for consistent module resolution
- Removed the default Vite demo code (App.css, counter logic) and replaced with a minimal Tailwind-styled App.tsx
- The scaffold creates `tsconfig.json`, `tsconfig.app.json` (for src), and `tsconfig.node.json` (for config files) - path aliases go in tsconfig.app.json
- vite.config.ts needs `resolve.alias` for runtime resolution, while tsconfig.app.json `paths` handles TypeScript compilation
- There's a peer dependency warning for @types/node version but it doesn't affect functionality
- Next task (setup-shadcn-ui) should run `pnpm dlx shadcn@latest init` from within packages/ui directory

## setup-shadcn-ui

- Shadcn/ui requires the path alias to be defined in the root `tsconfig.json` file, not just in `tsconfig.app.json` - it doesn't look at referenced configs
- Added `compilerOptions.baseUrl` and `compilerOptions.paths` to `packages/ui/tsconfig.json` to satisfy shadcn's validation
- Used non-interactive init with: `pnpm dlx shadcn@latest init --template vite --base-color neutral --yes --src-dir`
- `react-resizable-panels` v4.x has a breaking change: exports are now `Group`, `Panel`, `Separator` instead of `PanelGroup`, `Panel`, `PanelResizeHandle`
- The `direction` prop on ResizablePanelGroup was renamed to `orientation` in react-resizable-panels v4
- Had to manually fix `packages/ui/src/components/ui/resizable.tsx` to use the correct import names and prop names
- Installed 13 components: button, card, input, scroll-area, separator, resizable, tabs, dialog, dropdown-menu, alert, badge, skeleton, sonner
- Shadcn adds `tw-animate-css` package for animation utilities and uses Tailwind v4's `@theme inline` for CSS variables
- Created a demo App.tsx that showcases all installed components to verify they work correctly
- All components render and type-check correctly; build produces 399KB JS bundle

## ui-app-layout

- Replaced the component showcase App.tsx from setup-shadcn-ui with the actual app layout
- The layout uses `h-screen` with flexbox to fill full viewport height: header with `shrink-0` and main content with `flex-1`
- ResizablePanelGroup uses `orientation="horizontal"` (not `direction`) for side-by-side panels
- Each ResizablePanel has `defaultSize={50}` (percentage) and `minSize={30}` to prevent panels from being too small
- Added sub-headers to each panel ("Chat" and "Report") to help users understand the interface
- The main content area uses `overflow-hidden` to ensure resizable panels work correctly
- Left placeholder comments for where ChatPanel and ReportPanel components will be integrated
- The Toaster component is included at the app level for toast notifications throughout the app
- TypeScript check passes, build produces 288KB JS bundle (smaller than demo since unused imports removed)

## ui-chat-store

- Zustand v5 was installed (latest version) - uses the `create` function with standard patterns
- Store tests need to reset state in `beforeEach` using `useChatStore.setState()` to prevent test pollution
- Added `updateMessage` action not in original spec but needed for streaming responses (append content to existing assistant message)
- Added `deleteSession` action for session management (switching away from deleted session defaults to last remaining)
- Added `getCurrentSession` convenience method that uses `get()` to access current state
- ID generation uses `Date.now()` + random string for uniqueness without external dependencies
- Tests in UI package go in `src/store/*.test.ts` pattern (alongside source) per TASKS.md, unlike CLI which uses `test/` directory
- All 24 test cases cover: session CRUD, message add/update, session clearing, connection state flags, edge cases
- Zustand store is lightweight - no middleware needed for basic state management (persist middleware will be added later with IndexedDB)

## ui-report-store

- Defined `JSONRenderTree` as `Record<string, unknown>` placeholder - will be properly typed when `@json-render/core` is installed in the `setup-json-render` task
- The `setReport` action has dual behavior: creates new report for new sessions, updates existing report for same session (preserving id and createdAt)
- When updating an existing report without providing a title, the original title is preserved using nullish coalescing: `title: title ?? existingReport.title`
- Report store follows same patterns as chat store: `generateId()`, state reset in tests, `getCurrentReport` helper
- All 25 tests cover: creation, updates, session lookup, deletion with currentReportId handling, list operations, edge cases
- Report-session relationship is 1:1 (one report per session), enforced by `setReport` update logic

## ui-indexeddb-persistence

- Used `idb` library (v8.x) for IndexedDB with TypeScript - provides typed wrapper around IndexedDB API
- Added `fake-indexeddb` as devDependency for unit testing - provides in-memory IndexedDB implementation for Node.js/vitest
- GOTCHA: `fake-indexeddb/auto` must be imported FIRST in test files to polyfill `indexedDB` global before any other imports
- GOTCHA: Using `deleteDatabase()` with fake-indexeddb caused tests to hang indefinitely - instead use `clearAllData()` which clears object stores directly
- Database schema uses `DBSchema` interface from idb for type safety on object stores and indexes
- Created `sessionId` index on reports store using `createIndex("sessionId", "sessionId", { unique: false })` for efficient report-by-session lookups
- Integrated with Zustand stores using `subscribeWithSelector` middleware - enables subscribing to specific state slices for efficient persistence
- `subscribeToChatPersistence()` and `subscribeToReportPersistence()` functions return unsubscribe callbacks for cleanup
- Uses JSON.stringify comparison to detect actual data changes before persisting (avoids unnecessary IndexedDB writes)
- `initializeChatStore()` and `initializeReportStore()` async functions load data from IndexedDB on app startup
- `exportReportAsMarkdown()` recursively walks JSONRenderTree and converts to markdown with proper heading levels, lists, tables, etc.
- Tests cover all CRUD operations, edge cases, markdown export for all json-render component types (38 tests total)
- All 87 UI tests pass, typecheck succeeds, build produces 288KB bundle

## ui-websocket-client

- Used `partysocket` library for WebSocket with automatic reconnection, exponential backoff, message buffering, and connection timeout
- The WebSocketClient wrapper class provides typed message handling with `ClientMessage` and `ServerMessage` discriminated unions
- `ClientMessage` types: `query` (with content and optional sessionId), `cancel` (with optional sessionId)
- `ServerMessage` types: `text`, `tool_call`, `tool_result`, `report`, `error`, `done` - each with appropriate payloads
- Event handlers (onMessage, onError, onClose, onOpen) return unsubscribe functions for cleanup
- JSON parse errors in message handling are gracefully converted to error messages rather than throwing
- The `JSONRenderTree` type is placeholder `unknown` until json-render package is integrated
- For testing, mocked `partysocket` module with vi.mock() - mock implementation must include addEventListener/send/close methods
- GOTCHA: Mock must be created with methods in constructor, not added after - partysocket calls addEventListener immediately on construction
- Test helper `simulateEvent()` iterates over listeners Map to trigger handlers - simulates WebSocket events
- Tests cover: connection lifecycle, message sending/receiving, all server message types, handler unsubscription, error handling
- All 119 UI tests pass (32 websocket tests + previous 87)

## ui-websocket-hook

- Created `useWebSocket` hook in `packages/ui/src/hooks/useWebSocket.ts` that wraps WebSocketClient and integrates with Zustand stores
- Hook returns `{ isConnected, isStreaming, sendQuery, cancel }` - memoized with useMemo to prevent unnecessary re-renders
- CRITICAL GOTCHA: Do NOT include `currentSessionId` in useCallback dependencies for handlers used in the useEffect dependency array
  - When `sendQuery` calls `createSession()`, it updates the store which triggers a re-render
  - If `currentSessionId` is in `handleMessage`'s dependencies, the useEffect re-runs and creates a NEW WebSocketClient
  - This causes the old client to be disconnected and a new one created, losing the mock reference in tests
  - Solution: Read `currentSessionId` from store directly inside the callback using `useChatStore.getState().currentSessionId`
- Used refs (`clientRef`, `currentAssistantMessageIdRef`) for mutable state that shouldn't trigger re-renders
- Streaming text messages: First chunk creates new assistant message, subsequent chunks append to existing message
- The hook handles all ServerMessage types: text, tool_call, tool_result, report, error, done
- Error messages update the existing assistant message if streaming, or create a new one if not
- Testing React hooks requires `@testing-library/react` and jsdom environment (added `vitest.config.ts` with `environment: "jsdom"`)
- Had to create a separate `vitest.config.ts` because the test environment differs from the main Vite config
- Mock WebSocketClient was created using vi.mock() with factory that creates mock instance on each construction
- Tests store the mock instance in module-level variable to access handlers for simulating events
- All 29 hook tests pass, 148 total UI tests

## ui-chat-message-component

- Installed `streamdown` package for streaming-optimized markdown rendering - it handles incomplete/unterminated markdown blocks gracefully
- The `@source` directive in Tailwind v4 CSS allows including external files for class detection: `@source "../../../node_modules/streamdown/dist/*.js";`
- Streamdown is in root `node_modules/` not `packages/ui/node_modules/` due to pnpm workspace hoisting
- Component uses shadcn patterns: `cn()` utility for conditional classes, Tailwind utility classes
- User messages are plain text (no markdown), aligned right with `bg-primary text-primary-foreground`
- Assistant messages use Streamdown for markdown, aligned left with `bg-muted text-foreground`
- The streaming indicator uses CSS animation with staggered delays: `[animation-delay:0ms]`, `[animation-delay:150ms]`, `[animation-delay:300ms]`
- Added `@testing-library/jest-dom` for DOM matchers (toBeInTheDocument, toHaveClass, toHaveTextContent, etc.)
- IMPORTANT: Added `@testing-library/jest-dom` to `types` array in `tsconfig.app.json` to fix TypeScript errors for test files in `src/`
- Created `vitest.setup.ts` to import jest-dom matchers: `import "@testing-library/jest-dom/vitest";`
- Updated `vitest.config.ts` with `setupFiles: ["./vitest.setup.ts"]`
- GOTCHA: `toHaveTextContent` normalizes whitespace - use `element?.textContent` directly for exact whitespace matching
- Mocked streamdown in tests since it has complex dependencies and we only need to verify content is passed to it
- All 22 ChatMessage tests + 148 existing = 170 total UI tests, build produces 288KB bundle

## ui-chat-input-component

- Used `pnpm dlx shadcn@latest add textarea --yes` to install the shadcn Textarea component (wasn't installed during setup-shadcn-ui)
- Added `@testing-library/user-event` as devDependency for testing keyboard interactions (Enter to send, Shift+Enter for newline)
- Component follows props-based approach: `onSend`, `onCancel`, `isConnected`, `isStreaming` - making it easy to integrate with useWebSocket hook later
- Enter sends message (if valid), Shift+Enter inserts newline - implemented via `onKeyDown` handler with `e.preventDefault()` for Enter
- Send button and Cancel button are mutually exclusive - only one shows at a time based on `isStreaming` state
- ConnectionStatus is a separate subcomponent for the connection indicator (green/red dot with text)
- Input is disabled when `!isConnected || isStreaming` - prevents user interaction during inappropriate states
- Send button disabled when `value.trim().length === 0 || !isConnected || isStreaming`
- Auto-focus textarea on mount and when streaming ends (helps UX by returning focus after assistant response)
- Used inline SVG icons (SendIcon, StopIcon) to avoid adding icon library dependency - marked `aria-hidden="true"` for accessibility
- GOTCHA: TypeScript `verbatimModuleSyntax` requires `import type` for type-only imports - had to separate `ChatInputProps` import
- Tests cover: rendering, connection status indicator, input behavior, send functionality, cancel functionality, accessibility, focus behavior, edge cases
- All 39 ChatInput tests pass, total 209 UI tests, 384 CLI tests = 593 total tests

## ui-chat-panel

- Component composes ChatMessage list, ChatInput, and session history dropdown into a full chat interface
- Uses shadcn ScrollArea for scrollable message list and DropdownMenu for session history
- Auto-scroll implemented with `useRef` and `useEffect` that calls `scrollIntoView({ behavior: "smooth" })` on messages change
- GOTCHA: jsdom doesn't implement `scrollIntoView` - had to add mock in `vitest.setup.ts`: `Element.prototype.scrollIntoView = () => {}`
- Session dropdown shows in header: displays current session title, allows creating new sessions, switching between sessions, and deleting sessions
- Current session is highlighted in dropdown with `bg-accent` class applied conditionally
- Sessions sorted by `createdAt` descending (newest first) using `[...sessions].sort((a, b) => b.createdAt - a.createdAt)`
- Delete button uses `e.stopPropagation()` to prevent dropdown item click from triggering session switch
- GOTCHA: When current session title appears in both header and dropdown, tests using `getByText` fail with "multiple elements found" - use `getAllByText` instead
- Streaming indicator logic: only show on last message when `isStreaming && message.role === "assistant" && index === messages.length - 1`
- Empty state displays centered message icon with "No messages yet" text when `messages.length === 0`
- All inline SVG icons marked `aria-hidden="true"` for accessibility
- 36 tests cover: rendering, empty state, message display, chat input integration, session dropdown, session management, websocket integration, edge cases
- All 245 UI tests pass, 629 total tests (245 UI + 384 CLI)

## setup-json-render

- Added `@json-render/core`, `@json-render/react`, and `zod` as dependencies to `packages/ui/`
- `zod` is required as a peer dependency for json-render's schema validation - must be added explicitly
- The `createCatalog` function from `@json-render/core` creates a typed catalog with component definitions
- Each component definition has: `props` (zod schema), `hasChildren` (boolean), and optional `description` (string for AI prompts)
- Only `Card` component has `hasChildren: true` since it's the container component for nesting other elements
- The catalog exports: the catalog itself, individual component schemas (for reuse), type for the catalog, and UITree/UIElement types from json-render
- `catalog.validateElement()` and `catalog.validateTree()` methods validate against the schema and return `{ success, data?, error? }`
- Elements require a `key` field (unique identifier), `type` (component name), `props` (validated against schema), and optional `children`/`parentKey`
- UITree structure: `{ root: string, elements: Record<string, UIElement> }` - flat element map with root key reference
- Test file created alongside source at `src/lib/json-render/catalog.test.ts` with 53 tests covering all schemas and validation
- All 298 UI tests pass, build produces 288KB bundle (same as before - json-render tree-shakes well)

## json-render-shadcn-registry

- The `ComponentRegistry` type from `@json-render/react` is `Record<string, ComponentRenderer<any>>` where `ComponentRenderer` is a React component
- Each renderer receives `ComponentRenderProps<T>` with `element` (UIElement with props), `children` (ReactNode), `onAction`, and `loading`
- Access props via `element.props` (not directly passed) - this is the json-render pattern
- Installed shadcn Table component (`pnpm dlx shadcn@latest add table`) since it wasn't in the initial component list
- For typings, import schemas from catalog as `z.infer<typeof CardSchema>` etc. for props type narrowing
- Used type-only imports for schemas (`import type { CardSchema... }`) to satisfy TypeScript's `verbatimModuleSyntax`
- Heading levels are strings ("1"-"6") not numbers, per the catalog schema - cast Tag as union type for JSX
- Metric component uses custom Card composition (not the catalog Card) to display label/value/change with appropriate styling
- Code component uses `data-language` attribute for potential future syntax highlighting integration
- Tests use `createElement<T>()` helper to construct typed UIElement objects for component testing
- All 35 registry tests pass covering: component exports, all 10 renderers, variants, edge cases
- Build output unchanged at ~288KB - registry adds minimal bundle size

## ui-report-renderer

- Created `ReportRenderer` component that wraps json-render's `Renderer` component with loading/empty states
- The component accepts `report: UITree | null` and `isStreaming?: boolean` props
- Three main states: (1) empty state with icon when no report and not streaming, (2) loading skeleton when streaming without content, (3) report content when report exists
- Used `Renderer` from `@json-render/react` with the registry from `json-render-shadcn-registry` task - straightforward integration
- Loading skeleton mimics the structure of a typical report: title, cards, metrics grid, and table placeholder
- Streaming indicator shows animated bouncing dots with staggered delays using Tailwind's `[animation-delay:]` utility
- Created `FallbackComponent` for unknown component types - useful during development and when AI generates unrecognized components
- Tests mock `@json-render/react`'s Renderer and the registry to isolate component logic from json-render internals
- GOTCHA: The `UITree` type from `@json-render/core` has structure `{ root: string, elements: Record<string, UIElement> }` - not `JSONRenderTree` which was a placeholder
- The `DataProvider` from json-render is NOT needed for simple static report rendering - only required for dynamic data binding features
- All 27 ReportRenderer tests + previous 333 = 360 total UI tests, typecheck passes

## ui-report-panel

- Created `ReportPanel` component that composes `ReportRenderer` with a header toolbar for title, download, and history access
- The toolbar shows the current report title (or "No Report" fallback), a download button, and a history button that opens a dialog
- Download functionality uses `Blob` and `URL.createObjectURL()` to trigger file download of markdown export
- The history dialog lists all reports sorted by `createdAt` descending (newest first), showing title, date, and truncated session ID
- Each history item has three action buttons: view (switches to report), download, and delete
- GOTCHA: The `Report.content` is typed as `JSONRenderTree` (placeholder `Record<string, unknown>`) but `ReportRenderer` expects `UITree`
- Had to use type assertion `content as unknown as UITree` to bridge the type gap - at runtime the content will be a valid UITree
- GOTCHA: RadixUI ScrollArea requires `ResizeObserver` in jsdom - added mock in `vitest.setup.ts`: `globalThis.ResizeObserver = MockResizeObserver`
- GOTCHA: When testing dialog content, the current report title appears in both header AND dialog - use `within(dialog)` to query inside dialog only
- Added `DialogDescription` to fix accessibility warning about missing description for dialog content
- The view action updates `currentReportId` directly via `useReportStore.setState()` and closes the dialog
- Used same SVG icon patterns as `ChatPanel` (inline SVG with `aria-hidden="true"`)
- All 24 ReportPanel tests pass, 384 total UI tests, typecheck passes

## ui-report-history-dialog

- Extracted the report history dialog from `ReportPanel` into a standalone `ReportHistoryDialog` component for better modularity
- The component supports both controlled mode (`open`/`onOpenChange` props) and trigger mode (`trigger` prop for DialogTrigger)
- Refactored `ReportPanel` to use the new component - simplified from 330 lines to ~160 lines by removing inline dialog code
- GOTCHA: When testing text that spans multiple elements in React (like "Session: session-..."), use a function matcher instead of regex
  - The DOM has separate text nodes that don't match regex patterns
  - Solution: `getByText((_content, element) => element?.textContent?.includes("Session:") === true)`
- The dialog handlers use `useCallback` with store actions for memoization - no store state in dependency arrays
- Report list is sorted by `createdAt` descending (newest first) and highlights the current report with `border-primary bg-accent`
- Action buttons (view, download, delete) use same icon patterns from ReportPanel - kept for consistency
- View action both updates store state AND calls `onOpenChange(false)` to close dialog
- Delete action does NOT close dialog (allows deleting multiple reports without reopening)
- All 17 ReportHistoryDialog tests + 24 ReportPanel tests continue to pass (refactoring preserved existing test coverage)
- Total: 401 UI tests, 384 CLI tests = 785 tests passing

## cli-ws-server

- Added `ws` and `@types/ws` packages to `packages/cli/` for WebSocket server implementation
- Created `packages/cli/src/server/websocket.ts` with `PhoenixWebSocketServer` class that wraps the `ws` package
- The server uses `noServer: true` mode to handle HTTP upgrade requests manually, enabling path-based routing
- GOTCHA: When validating incoming JSON messages, parse as `unknown` first, then narrow types to avoid TypeScript's `never` type narrowing issue
  - Casting directly to `ClientMessage` then checking `message.type` causes TypeScript to narrow `message.type` to `never` after validation
  - Solution: Parse as `unknown`, validate structure with type guards, then cast after validation
- The `handleUpgrade` method filters connections by URL path (default `/ws`) - rejects connections on wrong paths by calling `socket.destroy()`
- Client tracking uses a `Set<WebSocket>` for fast add/remove operations
- Message protocol matches UI client types (`ClientMessage`, `ServerMessage`) from `packages/ui/src/lib/websocket.ts`
- GOTCHA: When testing WebSocket connection rejection on wrong path, the client may receive an `error` event rather than `close` event
  - Solution: Wait for either event using `Promise.race` pattern or combine handlers
- `broadcastToSession` currently broadcasts to all clients - session-to-client mapping deferred to `cli-agent-session` task
- Tests use real HTTP/WebSocket servers on random localhost ports (`:0` for auto-assignment) for realistic integration testing
- 25 new WebSocket tests: connection lifecycle, path filtering, message handling, error cases, broadcasting, graceful shutdown
- Total: 409 CLI tests, 401 UI tests = 810 tests passing

## cli-ui-server

- Created `packages/cli/src/server/ui.ts` that serves the UI package's static dist directory
- Added `@cephalization/phoenix-insight-ui` as a workspace dependency to CLI package: `"@cephalization/phoenix-insight-ui": "workspace:*"`
- Used `import.meta.resolve()` to locate the UI package's dist directory - returns a file URL that must be converted with `fileURLToPath()`
- Fallback path resolution looks for `../../ui/dist` relative to the server file (for development before packages are linked)
- SPA fallback logic: URLs with file extensions (`.js`, `.css`, etc.) are treated as assets, all others serve `index.html`
- GOTCHA: When using port 0 for random port assignment, must get the actual port AFTER the server starts listening via `httpServer.address().port`
- Directory traversal protection via path sanitization: decode URL, resolve full path, verify it starts with the base dist directory
- Encoded directory traversal attempts (like `%2e%2e%2f` for `../`) that resolve outside dist directory return 400 Bad Request
- Cache-Control headers: `no-cache` for `index.html` (always get latest for SPA), `max-age=31536000` for hashed assets
- MIME types map covers common web assets: html, css, js, json, svg, images, fonts, and source maps
- Server only binds to `127.0.0.1` (localhost) by default for security - no external network access
- `createUIServer()` returns a Promise with a `UIServer` object containing `httpServer`, `port`, `host`, `distPath`, and `close()` method
- 24 tests covering: initialization, static file serving, SPA fallback, caching, security (path traversal), and server lifecycle
- Total: 433 CLI tests, 401 UI tests = 834 tests passing

## cli-agent-session

- Created `packages/cli/src/server/session.ts` with `AgentSession` class for managing WebSocket client agent interactions
- `AgentSession` wraps `PhoenixInsightAgent` and provides session-specific broadcasting via a `BroadcastCallback` function
- Agent is created lazily on first query via `createInsightAgent()` and cached for session reuse
- Streaming implemented by iterating over `agent.stream()` result's `textStream` async iterator and sending each chunk
- Tool call and result notifications sent via `onStepFinish` callback passed to agent's stream method
- Conversation history maintained as `ConversationMessage[]` array with role, content, and timestamp
- Cancellation uses `AbortController` - check `abortController.signal.aborted` before each stream iteration and in `onStepFinish`
- `sendReport()` method and `getReportCallback()` factory for the report tool (to be implemented in cli-report-tool task)
- `SessionManager` class manages multiple sessions with WebSocket-to-session mapping
- Session ID used as key for session lookup; WebSocket client mapped separately to support multiple clients per session
- PATTERN: For testing async streams with mocks, use a `Promise<void>` that the test controls (`resolveStream()`) to pause/resume the stream
- GOTCHA: When testing streaming, need small `setTimeout` delays for async operations to start before checking `executing` state
- Tests mock `createInsightAgent` module with vi.mock() and return controlled mock agent objects
- Message collectors (`createMessageCollector()`) gather all broadcast messages for assertion
- 38 tests covering: AgentSession (constructor, id, executing, history, executeQuery, cancel, sendReport, clearHistory, cleanup), SessionManager (getOrCreateSession, getSessionForClient, getSession, removeSession, sessionCount, cleanup)
- Total: 471 CLI tests (38 new), 401 UI tests = 872 tests passing

## cli-report-tool

- Created `packages/cli/src/commands/report-tool.ts` with `createReportTool` factory function for the AI agent
- The tool uses AI SDK's `tool()` function with `inputSchema` (NOT `parameters`) and `execute` async function
- Duplicated zod schemas from UI's catalog because CLI can't import from UI package (UI depends on CLI, not vice versa)
- Schema duplication is intentional - CLI validates before sending, UI validates on receipt; both need the same rules
- The `UITreeSchema` uses `z.record(z.string(), UIElementSchema)` for the elements map
- Tool has a detailed description explaining all 10 component types and their props - this helps the AI understand how to structure reports
- The `validateReportContent` function performs deep validation: tree structure, root element existence, element props against component schemas, and child/parent reference integrity
- Props validation uses a switch statement mapping component types to their specific zod schemas
- Broadcast callback is passed via factory function closure - allows session to inject its own broadcast implementation
- Tool returns `ReportToolResult` with `{ success, message?, error? }` for clear AI feedback
- GOTCHA: AI SDK's `tool.execute` takes a second parameter `ToolExecutionOptions` with `toolCallId` and `messages` - test helper must provide mock options
- GOTCHA: When casting test data as `any` for execute, use `as const` on string literal types like `type: "Card" as const` to narrow types
- Exported from `commands/index.ts`: `createReportTool`, `validateReportContent`, `ReportToolInput`, `ReportToolResult`
- 37 new tests covering: validateReportContent (valid trees, invalid structure, invalid element structure, invalid props, relationship validation), createReportTool (definition, execute with valid/invalid content, broadcast errors), exports
- Total: 508 CLI tests, 401 UI tests = 909 tests passing
