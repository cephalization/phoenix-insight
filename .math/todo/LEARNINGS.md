# Project Learnings Log

This file is appended by each agent after completing a task.
Key insights, gotchas, and patterns discovered during implementation.

Use this knowledge to avoid repeating mistakes and build on what works.

---

<!-- Agents: Append your learnings below this line -->
<!-- Format:
## <task-id>

- Key insight or decision made
- Gotcha or pitfall discovered
- Pattern that worked well
- Anything the next agent should know
-->

## monorepo-init

- Converted the existing single-package root package.json into a workspace root by making it `private: true` and moving shared devDependencies
- The workspace scripts use `pnpm -r run <script>` to run scripts across all packages
- The pnpm-workspace.yaml file uses `packages/*` glob to match all packages in the packages directory
- The next task (move-cli-package) needs to recreate package.json inside packages/cli/ with all the CLI-specific dependencies that were removed from root (like @ai-sdk/anthropic, commander, etc.)
- Updated .gitignore to use `packages/*/dist/` pattern for ignoring build outputs in all packages
- The root package name changed to `phoenix-insight-monorepo` (private) - the CLI package should retain the original name `@cephalization/phoenix-insight`

## move-cli-package

- Used `git mv` to move `src/`, `test/`, `tsconfig.json`, `tsconfig.esm.json`, `README.md`, `.changeset/`, and `vitest.config.ts` to `packages/cli/`
- Also moved `CHANGELOG.md` (generated by changesets) to `packages/cli/`
- Removed the old `dist/` directory at root level (leftover from before monorepo structure)
- Created a new `packages/cli/package.json` by restoring the CLI-specific dependencies from git history (`git show f75f13f^:package.json`)
- The CLI package.json excludes shared devDependencies (rimraf, typescript, vitest, tsx, @types/node) that are now at root level
- No import paths needed to be changed because all internal imports use relative paths
- All 384 tests pass, build succeeds - the move was transparent to the codebase
- Next tasks will need to create `packages/ui/` for the UI package

## scaffold-ui-package

- Used `pnpm create vite packages/ui --template react-ts` to scaffold the base Vite React TypeScript app
- Updated package.json with name `@cephalization/phoenix-insight-ui`, added `"private": true`, and scripts for `clean`, `test`, `typecheck`
- Added `--passWithNoTests` to the test script since the scaffolded project has no test files initially - prevents CI failures
- Tailwind v4 uses the new `@tailwindcss/vite` plugin and `@import "tailwindcss"` in CSS instead of the old `@tailwind` directives
- Configured path alias `@/*` pointing to `./src/*` in both `tsconfig.app.json` (TypeScript) and `vite.config.ts` (Vite bundler) for consistent module resolution
- Removed the default Vite demo code (App.css, counter logic) and replaced with a minimal Tailwind-styled App.tsx
- The scaffold creates `tsconfig.json`, `tsconfig.app.json` (for src), and `tsconfig.node.json` (for config files) - path aliases go in tsconfig.app.json
- vite.config.ts needs `resolve.alias` for runtime resolution, while tsconfig.app.json `paths` handles TypeScript compilation
- There's a peer dependency warning for @types/node version but it doesn't affect functionality
- Next task (setup-shadcn-ui) should run `pnpm dlx shadcn@latest init` from within packages/ui directory

## setup-shadcn-ui

- Shadcn/ui requires the path alias to be defined in the root `tsconfig.json` file, not just in `tsconfig.app.json` - it doesn't look at referenced configs
- Added `compilerOptions.baseUrl` and `compilerOptions.paths` to `packages/ui/tsconfig.json` to satisfy shadcn's validation
- Used non-interactive init with: `pnpm dlx shadcn@latest init --template vite --base-color neutral --yes --src-dir`
- `react-resizable-panels` v4.x has a breaking change: exports are now `Group`, `Panel`, `Separator` instead of `PanelGroup`, `Panel`, `PanelResizeHandle`
- The `direction` prop on ResizablePanelGroup was renamed to `orientation` in react-resizable-panels v4
- Had to manually fix `packages/ui/src/components/ui/resizable.tsx` to use the correct import names and prop names
- Installed 13 components: button, card, input, scroll-area, separator, resizable, tabs, dialog, dropdown-menu, alert, badge, skeleton, sonner
- Shadcn adds `tw-animate-css` package for animation utilities and uses Tailwind v4's `@theme inline` for CSS variables
- Created a demo App.tsx that showcases all installed components to verify they work correctly
- All components render and type-check correctly; build produces 399KB JS bundle

## ui-app-layout

- Replaced the component showcase App.tsx from setup-shadcn-ui with the actual app layout
- The layout uses `h-screen` with flexbox to fill full viewport height: header with `shrink-0` and main content with `flex-1`
- ResizablePanelGroup uses `orientation="horizontal"` (not `direction`) for side-by-side panels
- Each ResizablePanel has `defaultSize={50}` (percentage) and `minSize={30}` to prevent panels from being too small
- Added sub-headers to each panel ("Chat" and "Report") to help users understand the interface
- The main content area uses `overflow-hidden` to ensure resizable panels work correctly
- Left placeholder comments for where ChatPanel and ReportPanel components will be integrated
- The Toaster component is included at the app level for toast notifications throughout the app
- TypeScript check passes, build produces 288KB JS bundle (smaller than demo since unused imports removed)

## ui-chat-store

- Zustand v5 was installed (latest version) - uses the `create` function with standard patterns
- Store tests need to reset state in `beforeEach` using `useChatStore.setState()` to prevent test pollution
- Added `updateMessage` action not in original spec but needed for streaming responses (append content to existing assistant message)
- Added `deleteSession` action for session management (switching away from deleted session defaults to last remaining)
- Added `getCurrentSession` convenience method that uses `get()` to access current state
- ID generation uses `Date.now()` + random string for uniqueness without external dependencies
- Tests in UI package go in `src/store/*.test.ts` pattern (alongside source) per TASKS.md, unlike CLI which uses `test/` directory
- All 24 test cases cover: session CRUD, message add/update, session clearing, connection state flags, edge cases
- Zustand store is lightweight - no middleware needed for basic state management (persist middleware will be added later with IndexedDB)

## ui-report-store

- Defined `JSONRenderTree` as `Record<string, unknown>` placeholder - will be properly typed when `@json-render/core` is installed in the `setup-json-render` task
- The `setReport` action has dual behavior: creates new report for new sessions, updates existing report for same session (preserving id and createdAt)
- When updating an existing report without providing a title, the original title is preserved using nullish coalescing: `title: title ?? existingReport.title`
- Report store follows same patterns as chat store: `generateId()`, state reset in tests, `getCurrentReport` helper
- All 25 tests cover: creation, updates, session lookup, deletion with currentReportId handling, list operations, edge cases
- Report-session relationship is 1:1 (one report per session), enforced by `setReport` update logic

## ui-indexeddb-persistence

- Used `idb` library (v8.x) for IndexedDB with TypeScript - provides typed wrapper around IndexedDB API
- Added `fake-indexeddb` as devDependency for unit testing - provides in-memory IndexedDB implementation for Node.js/vitest
- GOTCHA: `fake-indexeddb/auto` must be imported FIRST in test files to polyfill `indexedDB` global before any other imports
- GOTCHA: Using `deleteDatabase()` with fake-indexeddb caused tests to hang indefinitely - instead use `clearAllData()` which clears object stores directly
- Database schema uses `DBSchema` interface from idb for type safety on object stores and indexes
- Created `sessionId` index on reports store using `createIndex("sessionId", "sessionId", { unique: false })` for efficient report-by-session lookups
- Integrated with Zustand stores using `subscribeWithSelector` middleware - enables subscribing to specific state slices for efficient persistence
- `subscribeToChatPersistence()` and `subscribeToReportPersistence()` functions return unsubscribe callbacks for cleanup
- Uses JSON.stringify comparison to detect actual data changes before persisting (avoids unnecessary IndexedDB writes)
- `initializeChatStore()` and `initializeReportStore()` async functions load data from IndexedDB on app startup
- `exportReportAsMarkdown()` recursively walks JSONRenderTree and converts to markdown with proper heading levels, lists, tables, etc.
- Tests cover all CRUD operations, edge cases, markdown export for all json-render component types (38 tests total)
- All 87 UI tests pass, typecheck succeeds, build produces 288KB bundle

## ui-websocket-client

- Used `partysocket` library for WebSocket with automatic reconnection, exponential backoff, message buffering, and connection timeout
- The WebSocketClient wrapper class provides typed message handling with `ClientMessage` and `ServerMessage` discriminated unions
- `ClientMessage` types: `query` (with content and optional sessionId), `cancel` (with optional sessionId)
- `ServerMessage` types: `text`, `tool_call`, `tool_result`, `report`, `error`, `done` - each with appropriate payloads
- Event handlers (onMessage, onError, onClose, onOpen) return unsubscribe functions for cleanup
- JSON parse errors in message handling are gracefully converted to error messages rather than throwing
- The `JSONRenderTree` type is placeholder `unknown` until json-render package is integrated
- For testing, mocked `partysocket` module with vi.mock() - mock implementation must include addEventListener/send/close methods
- GOTCHA: Mock must be created with methods in constructor, not added after - partysocket calls addEventListener immediately on construction
- Test helper `simulateEvent()` iterates over listeners Map to trigger handlers - simulates WebSocket events
- Tests cover: connection lifecycle, message sending/receiving, all server message types, handler unsubscription, error handling
- All 119 UI tests pass (32 websocket tests + previous 87)

## ui-websocket-hook

- Created `useWebSocket` hook in `packages/ui/src/hooks/useWebSocket.ts` that wraps WebSocketClient and integrates with Zustand stores
- Hook returns `{ isConnected, isStreaming, sendQuery, cancel }` - memoized with useMemo to prevent unnecessary re-renders
- CRITICAL GOTCHA: Do NOT include `currentSessionId` in useCallback dependencies for handlers used in the useEffect dependency array
  - When `sendQuery` calls `createSession()`, it updates the store which triggers a re-render
  - If `currentSessionId` is in `handleMessage`'s dependencies, the useEffect re-runs and creates a NEW WebSocketClient
  - This causes the old client to be disconnected and a new one created, losing the mock reference in tests
  - Solution: Read `currentSessionId` from store directly inside the callback using `useChatStore.getState().currentSessionId`
- Used refs (`clientRef`, `currentAssistantMessageIdRef`) for mutable state that shouldn't trigger re-renders
- Streaming text messages: First chunk creates new assistant message, subsequent chunks append to existing message
- The hook handles all ServerMessage types: text, tool_call, tool_result, report, error, done
- Error messages update the existing assistant message if streaming, or create a new one if not
- Testing React hooks requires `@testing-library/react` and jsdom environment (added `vitest.config.ts` with `environment: "jsdom"`)
- Had to create a separate `vitest.config.ts` because the test environment differs from the main Vite config
- Mock WebSocketClient was created using vi.mock() with factory that creates mock instance on each construction
- Tests store the mock instance in module-level variable to access handlers for simulating events
- All 29 hook tests pass, 148 total UI tests
