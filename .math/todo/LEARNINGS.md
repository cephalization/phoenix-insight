# Project Learnings Log

This file is appended by each agent after completing a task.
Key insights, gotchas, and patterns discovered during implementation.

Use this knowledge to avoid repeating mistakes and build on what works.

---

<!-- Agents: Append your learnings below this line -->
<!-- Format:
## <task-id>

- Key insight or decision made
- Gotcha or pitfall discovered
- Pattern that worked well
- Anything the next agent should know
-->

## monorepo-init

- Converted the existing single-package root package.json into a workspace root by making it `private: true` and moving shared devDependencies
- The workspace scripts use `pnpm -r run <script>` to run scripts across all packages
- The pnpm-workspace.yaml file uses `packages/*` glob to match all packages in the packages directory
- The next task (move-cli-package) needs to recreate package.json inside packages/cli/ with all the CLI-specific dependencies that were removed from root (like @ai-sdk/anthropic, commander, etc.)
- Updated .gitignore to use `packages/*/dist/` pattern for ignoring build outputs in all packages
- The root package name changed to `phoenix-insight-monorepo` (private) - the CLI package should retain the original name `@cephalization/phoenix-insight`

## move-cli-package

- Used `git mv` to move `src/`, `test/`, `tsconfig.json`, `tsconfig.esm.json`, `README.md`, `.changeset/`, and `vitest.config.ts` to `packages/cli/`
- Also moved `CHANGELOG.md` (generated by changesets) to `packages/cli/`
- Removed the old `dist/` directory at root level (leftover from before monorepo structure)
- Created a new `packages/cli/package.json` by restoring the CLI-specific dependencies from git history (`git show f75f13f^:package.json`)
- The CLI package.json excludes shared devDependencies (rimraf, typescript, vitest, tsx, @types/node) that are now at root level
- No import paths needed to be changed because all internal imports use relative paths
- All 384 tests pass, build succeeds - the move was transparent to the codebase
- Next tasks will need to create `packages/ui/` for the UI package

## scaffold-ui-package

- Used `pnpm create vite packages/ui --template react-ts` to scaffold the base Vite React TypeScript app
- Updated package.json with name `@cephalization/phoenix-insight-ui`, added `"private": true`, and scripts for `clean`, `test`, `typecheck`
- Added `--passWithNoTests` to the test script since the scaffolded project has no test files initially - prevents CI failures
- Tailwind v4 uses the new `@tailwindcss/vite` plugin and `@import "tailwindcss"` in CSS instead of the old `@tailwind` directives
- Configured path alias `@/*` pointing to `./src/*` in both `tsconfig.app.json` (TypeScript) and `vite.config.ts` (Vite bundler) for consistent module resolution
- Removed the default Vite demo code (App.css, counter logic) and replaced with a minimal Tailwind-styled App.tsx
- The scaffold creates `tsconfig.json`, `tsconfig.app.json` (for src), and `tsconfig.node.json` (for config files) - path aliases go in tsconfig.app.json
- vite.config.ts needs `resolve.alias` for runtime resolution, while tsconfig.app.json `paths` handles TypeScript compilation
- There's a peer dependency warning for @types/node version but it doesn't affect functionality
- Next task (setup-shadcn-ui) should run `pnpm dlx shadcn@latest init` from within packages/ui directory

## setup-shadcn-ui

- Shadcn/ui requires the path alias to be defined in the root `tsconfig.json` file, not just in `tsconfig.app.json` - it doesn't look at referenced configs
- Added `compilerOptions.baseUrl` and `compilerOptions.paths` to `packages/ui/tsconfig.json` to satisfy shadcn's validation
- Used non-interactive init with: `pnpm dlx shadcn@latest init --template vite --base-color neutral --yes --src-dir`
- `react-resizable-panels` v4.x has a breaking change: exports are now `Group`, `Panel`, `Separator` instead of `PanelGroup`, `Panel`, `PanelResizeHandle`
- The `direction` prop on ResizablePanelGroup was renamed to `orientation` in react-resizable-panels v4
- Had to manually fix `packages/ui/src/components/ui/resizable.tsx` to use the correct import names and prop names
- Installed 13 components: button, card, input, scroll-area, separator, resizable, tabs, dialog, dropdown-menu, alert, badge, skeleton, sonner
- Shadcn adds `tw-animate-css` package for animation utilities and uses Tailwind v4's `@theme inline` for CSS variables
- Created a demo App.tsx that showcases all installed components to verify they work correctly
- All components render and type-check correctly; build produces 399KB JS bundle

## ui-app-layout

- Replaced the component showcase App.tsx from setup-shadcn-ui with the actual app layout
- The layout uses `h-screen` with flexbox to fill full viewport height: header with `shrink-0` and main content with `flex-1`
- ResizablePanelGroup uses `orientation="horizontal"` (not `direction`) for side-by-side panels
- Each ResizablePanel has `defaultSize={50}` (percentage) and `minSize={30}` to prevent panels from being too small
- Added sub-headers to each panel ("Chat" and "Report") to help users understand the interface
- The main content area uses `overflow-hidden` to ensure resizable panels work correctly
- Left placeholder comments for where ChatPanel and ReportPanel components will be integrated
- The Toaster component is included at the app level for toast notifications throughout the app
- TypeScript check passes, build produces 288KB JS bundle (smaller than demo since unused imports removed)

## ui-chat-store

- Zustand v5 was installed (latest version) - uses the `create` function with standard patterns
- Store tests need to reset state in `beforeEach` using `useChatStore.setState()` to prevent test pollution
- Added `updateMessage` action not in original spec but needed for streaming responses (append content to existing assistant message)
- Added `deleteSession` action for session management (switching away from deleted session defaults to last remaining)
- Added `getCurrentSession` convenience method that uses `get()` to access current state
- ID generation uses `Date.now()` + random string for uniqueness without external dependencies
- Tests in UI package go in `src/store/*.test.ts` pattern (alongside source) per TASKS.md, unlike CLI which uses `test/` directory
- All 24 test cases cover: session CRUD, message add/update, session clearing, connection state flags, edge cases
- Zustand store is lightweight - no middleware needed for basic state management (persist middleware will be added later with IndexedDB)

## ui-report-store

- Defined `JSONRenderTree` as `Record<string, unknown>` placeholder - will be properly typed when `@json-render/core` is installed in the `setup-json-render` task
- The `setReport` action has dual behavior: creates new report for new sessions, updates existing report for same session (preserving id and createdAt)
- When updating an existing report without providing a title, the original title is preserved using nullish coalescing: `title: title ?? existingReport.title`
- Report store follows same patterns as chat store: `generateId()`, state reset in tests, `getCurrentReport` helper
- All 25 tests cover: creation, updates, session lookup, deletion with currentReportId handling, list operations, edge cases
- Report-session relationship is 1:1 (one report per session), enforced by `setReport` update logic

## ui-indexeddb-persistence

- Used `idb` library (v8.x) for IndexedDB with TypeScript - provides typed wrapper around IndexedDB API
- Added `fake-indexeddb` as devDependency for unit testing - provides in-memory IndexedDB implementation for Node.js/vitest
- GOTCHA: `fake-indexeddb/auto` must be imported FIRST in test files to polyfill `indexedDB` global before any other imports
- GOTCHA: Using `deleteDatabase()` with fake-indexeddb caused tests to hang indefinitely - instead use `clearAllData()` which clears object stores directly
- Database schema uses `DBSchema` interface from idb for type safety on object stores and indexes
- Created `sessionId` index on reports store using `createIndex("sessionId", "sessionId", { unique: false })` for efficient report-by-session lookups
- Integrated with Zustand stores using `subscribeWithSelector` middleware - enables subscribing to specific state slices for efficient persistence
- `subscribeToChatPersistence()` and `subscribeToReportPersistence()` functions return unsubscribe callbacks for cleanup
- Uses JSON.stringify comparison to detect actual data changes before persisting (avoids unnecessary IndexedDB writes)
- `initializeChatStore()` and `initializeReportStore()` async functions load data from IndexedDB on app startup
- `exportReportAsMarkdown()` recursively walks JSONRenderTree and converts to markdown with proper heading levels, lists, tables, etc.
- Tests cover all CRUD operations, edge cases, markdown export for all json-render component types (38 tests total)
- All 87 UI tests pass, typecheck succeeds, build produces 288KB bundle

## ui-websocket-client

- Used `partysocket` library for WebSocket with automatic reconnection, exponential backoff, message buffering, and connection timeout
- The WebSocketClient wrapper class provides typed message handling with `ClientMessage` and `ServerMessage` discriminated unions
- `ClientMessage` types: `query` (with content and optional sessionId), `cancel` (with optional sessionId)
- `ServerMessage` types: `text`, `tool_call`, `tool_result`, `report`, `error`, `done` - each with appropriate payloads
- Event handlers (onMessage, onError, onClose, onOpen) return unsubscribe functions for cleanup
- JSON parse errors in message handling are gracefully converted to error messages rather than throwing
- The `JSONRenderTree` type is placeholder `unknown` until json-render package is integrated
- For testing, mocked `partysocket` module with vi.mock() - mock implementation must include addEventListener/send/close methods
- GOTCHA: Mock must be created with methods in constructor, not added after - partysocket calls addEventListener immediately on construction
- Test helper `simulateEvent()` iterates over listeners Map to trigger handlers - simulates WebSocket events
- Tests cover: connection lifecycle, message sending/receiving, all server message types, handler unsubscription, error handling
- All 119 UI tests pass (32 websocket tests + previous 87)

## ui-websocket-hook

- Created `useWebSocket` hook in `packages/ui/src/hooks/useWebSocket.ts` that wraps WebSocketClient and integrates with Zustand stores
- Hook returns `{ isConnected, isStreaming, sendQuery, cancel }` - memoized with useMemo to prevent unnecessary re-renders
- CRITICAL GOTCHA: Do NOT include `currentSessionId` in useCallback dependencies for handlers used in the useEffect dependency array
  - When `sendQuery` calls `createSession()`, it updates the store which triggers a re-render
  - If `currentSessionId` is in `handleMessage`'s dependencies, the useEffect re-runs and creates a NEW WebSocketClient
  - This causes the old client to be disconnected and a new one created, losing the mock reference in tests
  - Solution: Read `currentSessionId` from store directly inside the callback using `useChatStore.getState().currentSessionId`
- Used refs (`clientRef`, `currentAssistantMessageIdRef`) for mutable state that shouldn't trigger re-renders
- Streaming text messages: First chunk creates new assistant message, subsequent chunks append to existing message
- The hook handles all ServerMessage types: text, tool_call, tool_result, report, error, done
- Error messages update the existing assistant message if streaming, or create a new one if not
- Testing React hooks requires `@testing-library/react` and jsdom environment (added `vitest.config.ts` with `environment: "jsdom"`)
- Had to create a separate `vitest.config.ts` because the test environment differs from the main Vite config
- Mock WebSocketClient was created using vi.mock() with factory that creates mock instance on each construction
- Tests store the mock instance in module-level variable to access handlers for simulating events
- All 29 hook tests pass, 148 total UI tests

## ui-chat-message-component

- Installed `streamdown` package for streaming-optimized markdown rendering - it handles incomplete/unterminated markdown blocks gracefully
- The `@source` directive in Tailwind v4 CSS allows including external files for class detection: `@source "../../../node_modules/streamdown/dist/*.js";`
- Streamdown is in root `node_modules/` not `packages/ui/node_modules/` due to pnpm workspace hoisting
- Component uses shadcn patterns: `cn()` utility for conditional classes, Tailwind utility classes
- User messages are plain text (no markdown), aligned right with `bg-primary text-primary-foreground`
- Assistant messages use Streamdown for markdown, aligned left with `bg-muted text-foreground`
- The streaming indicator uses CSS animation with staggered delays: `[animation-delay:0ms]`, `[animation-delay:150ms]`, `[animation-delay:300ms]`
- Added `@testing-library/jest-dom` for DOM matchers (toBeInTheDocument, toHaveClass, toHaveTextContent, etc.)
- IMPORTANT: Added `@testing-library/jest-dom` to `types` array in `tsconfig.app.json` to fix TypeScript errors for test files in `src/`
- Created `vitest.setup.ts` to import jest-dom matchers: `import "@testing-library/jest-dom/vitest";`
- Updated `vitest.config.ts` with `setupFiles: ["./vitest.setup.ts"]`
- GOTCHA: `toHaveTextContent` normalizes whitespace - use `element?.textContent` directly for exact whitespace matching
- Mocked streamdown in tests since it has complex dependencies and we only need to verify content is passed to it
- All 22 ChatMessage tests + 148 existing = 170 total UI tests, build produces 288KB bundle

## ui-chat-input-component

- Used `pnpm dlx shadcn@latest add textarea --yes` to install the shadcn Textarea component (wasn't installed during setup-shadcn-ui)
- Added `@testing-library/user-event` as devDependency for testing keyboard interactions (Enter to send, Shift+Enter for newline)
- Component follows props-based approach: `onSend`, `onCancel`, `isConnected`, `isStreaming` - making it easy to integrate with useWebSocket hook later
- Enter sends message (if valid), Shift+Enter inserts newline - implemented via `onKeyDown` handler with `e.preventDefault()` for Enter
- Send button and Cancel button are mutually exclusive - only one shows at a time based on `isStreaming` state
- ConnectionStatus is a separate subcomponent for the connection indicator (green/red dot with text)
- Input is disabled when `!isConnected || isStreaming` - prevents user interaction during inappropriate states
- Send button disabled when `value.trim().length === 0 || !isConnected || isStreaming`
- Auto-focus textarea on mount and when streaming ends (helps UX by returning focus after assistant response)
- Used inline SVG icons (SendIcon, StopIcon) to avoid adding icon library dependency - marked `aria-hidden="true"` for accessibility
- GOTCHA: TypeScript `verbatimModuleSyntax` requires `import type` for type-only imports - had to separate `ChatInputProps` import
- Tests cover: rendering, connection status indicator, input behavior, send functionality, cancel functionality, accessibility, focus behavior, edge cases
- All 39 ChatInput tests pass, total 209 UI tests, 384 CLI tests = 593 total tests

## ui-chat-panel

- Component composes ChatMessage list, ChatInput, and session history dropdown into a full chat interface
- Uses shadcn ScrollArea for scrollable message list and DropdownMenu for session history
- Auto-scroll implemented with `useRef` and `useEffect` that calls `scrollIntoView({ behavior: "smooth" })` on messages change
- GOTCHA: jsdom doesn't implement `scrollIntoView` - had to add mock in `vitest.setup.ts`: `Element.prototype.scrollIntoView = () => {}`
- Session dropdown shows in header: displays current session title, allows creating new sessions, switching between sessions, and deleting sessions
- Current session is highlighted in dropdown with `bg-accent` class applied conditionally
- Sessions sorted by `createdAt` descending (newest first) using `[...sessions].sort((a, b) => b.createdAt - a.createdAt)`
- Delete button uses `e.stopPropagation()` to prevent dropdown item click from triggering session switch
- GOTCHA: When current session title appears in both header and dropdown, tests using `getByText` fail with "multiple elements found" - use `getAllByText` instead
- Streaming indicator logic: only show on last message when `isStreaming && message.role === "assistant" && index === messages.length - 1`
- Empty state displays centered message icon with "No messages yet" text when `messages.length === 0`
- All inline SVG icons marked `aria-hidden="true"` for accessibility
- 36 tests cover: rendering, empty state, message display, chat input integration, session dropdown, session management, websocket integration, edge cases
- All 245 UI tests pass, 629 total tests (245 UI + 384 CLI)

## setup-json-render

- Added `@json-render/core`, `@json-render/react`, and `zod` as dependencies to `packages/ui/`
- `zod` is required as a peer dependency for json-render's schema validation - must be added explicitly
- The `createCatalog` function from `@json-render/core` creates a typed catalog with component definitions
- Each component definition has: `props` (zod schema), `hasChildren` (boolean), and optional `description` (string for AI prompts)
- Only `Card` component has `hasChildren: true` since it's the container component for nesting other elements
- The catalog exports: the catalog itself, individual component schemas (for reuse), type for the catalog, and UITree/UIElement types from json-render
- `catalog.validateElement()` and `catalog.validateTree()` methods validate against the schema and return `{ success, data?, error? }`
- Elements require a `key` field (unique identifier), `type` (component name), `props` (validated against schema), and optional `children`/`parentKey`
- UITree structure: `{ root: string, elements: Record<string, UIElement> }` - flat element map with root key reference
- Test file created alongside source at `src/lib/json-render/catalog.test.ts` with 53 tests covering all schemas and validation
- All 298 UI tests pass, build produces 288KB bundle (same as before - json-render tree-shakes well)

## json-render-shadcn-registry

- The `ComponentRegistry` type from `@json-render/react` is `Record<string, ComponentRenderer<any>>` where `ComponentRenderer` is a React component
- Each renderer receives `ComponentRenderProps<T>` with `element` (UIElement with props), `children` (ReactNode), `onAction`, and `loading`
- Access props via `element.props` (not directly passed) - this is the json-render pattern
- Installed shadcn Table component (`pnpm dlx shadcn@latest add table`) since it wasn't in the initial component list
- For typings, import schemas from catalog as `z.infer<typeof CardSchema>` etc. for props type narrowing
- Used type-only imports for schemas (`import type { CardSchema... }`) to satisfy TypeScript's `verbatimModuleSyntax`
- Heading levels are strings ("1"-"6") not numbers, per the catalog schema - cast Tag as union type for JSX
- Metric component uses custom Card composition (not the catalog Card) to display label/value/change with appropriate styling
- Code component uses `data-language` attribute for potential future syntax highlighting integration
- Tests use `createElement<T>()` helper to construct typed UIElement objects for component testing
- All 35 registry tests pass covering: component exports, all 10 renderers, variants, edge cases
- Build output unchanged at ~288KB - registry adds minimal bundle size

## ui-report-renderer

- Created `ReportRenderer` component that wraps json-render's `Renderer` component with loading/empty states
- The component accepts `report: UITree | null` and `isStreaming?: boolean` props
- Three main states: (1) empty state with icon when no report and not streaming, (2) loading skeleton when streaming without content, (3) report content when report exists
- Used `Renderer` from `@json-render/react` with the registry from `json-render-shadcn-registry` task - straightforward integration
- Loading skeleton mimics the structure of a typical report: title, cards, metrics grid, and table placeholder
- Streaming indicator shows animated bouncing dots with staggered delays using Tailwind's `[animation-delay:]` utility
- Created `FallbackComponent` for unknown component types - useful during development and when AI generates unrecognized components
- Tests mock `@json-render/react`'s Renderer and the registry to isolate component logic from json-render internals
- GOTCHA: The `UITree` type from `@json-render/core` has structure `{ root: string, elements: Record<string, UIElement> }` - not `JSONRenderTree` which was a placeholder
- The `DataProvider` from json-render is NOT needed for simple static report rendering - only required for dynamic data binding features
- All 27 ReportRenderer tests + previous 333 = 360 total UI tests, typecheck passes
